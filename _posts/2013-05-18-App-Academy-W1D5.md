---
title: Algos - DFS and BFS
layout: default
---

# Algos: DFS and BFS

Friday! Today was a good day. We learned about and implemented two handy algorithms: Depth First Search and Breadth First Search. At first, i struggled with the implementation of DFS because I didn’t understand how one would backtrace after encountering a dead end, until Ned explained there is no backtrace. The way I understand it now is that we choose a direction (say left), to search down a tree. We ask if our current node is the node we’re looking for, if so, we return the node, else we check both the left and right nodes (if they exist). If there’s a left child, we call DFS on that node, and if there’s a right child, we call DFS on the right child. What i didn’t understand at first was that if our current node is not the correct node, there will be recursive calls to DFS down the left branch of the tree, and if we haven’t found anything down the left branch, we don’t actually backtrack back up. Instead we step into right right child and recursively check down that path (going left first wherever possible, then right). I still need to review the problems of the day to better understand how to implement this. 

Breadth first search was much easier for me to conceptualize. We have a queue, then we push the root node into the queue. Then we step into a loop that won’t end until our queue is empty. At the top of our loop, we shift the parent (in this case, our root) node out of the queue. We check if this node is the node we’re looking for. If so, return, else push all of its children into the queue. On our next time through the loop, we have a queue full of these children. We then shift out the first child, then check if this node is the node we’re looking for. If it is, return, else push all of its children into the queue. At this point, our queue, in order from left to right, should have all of our root node’s children (except the one we just shifted out), and then behind them, we should have all the children of the node (root’s child) we just shifted out of the queue. We keep repeating this cycle, where we step down a level in our tree, checking if any of these children are the nodes we’re looking for. Once we check all the children, then we check all of the children’s children. The loop will end if we find the node we’re looking for, or until the queue is empty, which would mean that the node does not exist in the tree. 

As I was writing this, i have come to the realization that this writing assignment is hugely important!. As I was explaining, there were points that i realized i was fuzzy on, so this exercise is a great way of illuminating these gaps in understanding. This exercise will also improve my ability to communicate my thoughts to my programming partner in a coherent manner. If i am unable to communicate properly, then i must not have a clear idea or understanding of the concepts i wish to employ. I’m tempted to backtrace through the curriculum and try explaining each one again!

Also, I need to be better about studying Ned’s solutions to the problems and projects of each day. These practices (writing about what i’ve learned and studying code more advanced than mine) are huge! I must not neglect these. 